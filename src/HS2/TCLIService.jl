#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



# types encapsulating arguments and return values of method OpenSession

mutable struct OpenSession_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function OpenSession_args(; kwargs...)
    obj = new(__meta__OpenSession_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct OpenSession_args

const __meta__OpenSession_args = meta(OpenSession_args,
  Symbol[:req],
  Type[TOpenSessionReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::OpenSession_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TOpenSessionReq
  else
    getfield(obj, name)
  end
end

meta(::Type{OpenSession_args}) = __meta__OpenSession_args



mutable struct OpenSession_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function OpenSession_result(; kwargs...)
    obj = new(__meta__OpenSession_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct OpenSession_result

const __meta__OpenSession_result = meta(OpenSession_result,
  Symbol[:success],
  Type[TOpenSessionResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::OpenSession_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TOpenSessionResp
  else
    getfield(obj, name)
  end
end

meta(::Type{OpenSession_result}) = __meta__OpenSession_result


# types encapsulating arguments and return values of method CloseSession

mutable struct CloseSession_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CloseSession_args(; kwargs...)
    obj = new(__meta__CloseSession_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CloseSession_args

const __meta__CloseSession_args = meta(CloseSession_args,
  Symbol[:req],
  Type[TCloseSessionReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CloseSession_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TCloseSessionReq
  else
    getfield(obj, name)
  end
end

meta(::Type{CloseSession_args}) = __meta__CloseSession_args



mutable struct CloseSession_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CloseSession_result(; kwargs...)
    obj = new(__meta__CloseSession_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CloseSession_result

const __meta__CloseSession_result = meta(CloseSession_result,
  Symbol[:success],
  Type[TCloseSessionResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CloseSession_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TCloseSessionResp
  else
    getfield(obj, name)
  end
end

meta(::Type{CloseSession_result}) = __meta__CloseSession_result


# types encapsulating arguments and return values of method GetInfo

mutable struct GetInfo_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetInfo_args(; kwargs...)
    obj = new(__meta__GetInfo_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetInfo_args

const __meta__GetInfo_args = meta(GetInfo_args,
  Symbol[:req],
  Type[TGetInfoReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetInfo_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetInfoReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetInfo_args}) = __meta__GetInfo_args



mutable struct GetInfo_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetInfo_result(; kwargs...)
    obj = new(__meta__GetInfo_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetInfo_result

const __meta__GetInfo_result = meta(GetInfo_result,
  Symbol[:success],
  Type[TGetInfoResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetInfo_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetInfoResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetInfo_result}) = __meta__GetInfo_result


# types encapsulating arguments and return values of method ExecuteStatement

mutable struct ExecuteStatement_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function ExecuteStatement_args(; kwargs...)
    obj = new(__meta__ExecuteStatement_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct ExecuteStatement_args

const __meta__ExecuteStatement_args = meta(ExecuteStatement_args,
  Symbol[:req],
  Type[TExecuteStatementReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::ExecuteStatement_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TExecuteStatementReq
  else
    getfield(obj, name)
  end
end

meta(::Type{ExecuteStatement_args}) = __meta__ExecuteStatement_args



mutable struct ExecuteStatement_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function ExecuteStatement_result(; kwargs...)
    obj = new(__meta__ExecuteStatement_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct ExecuteStatement_result

const __meta__ExecuteStatement_result = meta(ExecuteStatement_result,
  Symbol[:success],
  Type[TExecuteStatementResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::ExecuteStatement_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TExecuteStatementResp
  else
    getfield(obj, name)
  end
end

meta(::Type{ExecuteStatement_result}) = __meta__ExecuteStatement_result


# types encapsulating arguments and return values of method GetTypeInfo

mutable struct GetTypeInfo_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTypeInfo_args(; kwargs...)
    obj = new(__meta__GetTypeInfo_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTypeInfo_args

const __meta__GetTypeInfo_args = meta(GetTypeInfo_args,
  Symbol[:req],
  Type[TGetTypeInfoReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTypeInfo_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetTypeInfoReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTypeInfo_args}) = __meta__GetTypeInfo_args



mutable struct GetTypeInfo_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTypeInfo_result(; kwargs...)
    obj = new(__meta__GetTypeInfo_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTypeInfo_result

const __meta__GetTypeInfo_result = meta(GetTypeInfo_result,
  Symbol[:success],
  Type[TGetTypeInfoResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTypeInfo_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetTypeInfoResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTypeInfo_result}) = __meta__GetTypeInfo_result


# types encapsulating arguments and return values of method GetCatalogs

mutable struct GetCatalogs_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetCatalogs_args(; kwargs...)
    obj = new(__meta__GetCatalogs_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetCatalogs_args

const __meta__GetCatalogs_args = meta(GetCatalogs_args,
  Symbol[:req],
  Type[TGetCatalogsReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetCatalogs_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetCatalogsReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetCatalogs_args}) = __meta__GetCatalogs_args



mutable struct GetCatalogs_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetCatalogs_result(; kwargs...)
    obj = new(__meta__GetCatalogs_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetCatalogs_result

const __meta__GetCatalogs_result = meta(GetCatalogs_result,
  Symbol[:success],
  Type[TGetCatalogsResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetCatalogs_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetCatalogsResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetCatalogs_result}) = __meta__GetCatalogs_result


# types encapsulating arguments and return values of method GetSchemas

mutable struct GetSchemas_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetSchemas_args(; kwargs...)
    obj = new(__meta__GetSchemas_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetSchemas_args

const __meta__GetSchemas_args = meta(GetSchemas_args,
  Symbol[:req],
  Type[TGetSchemasReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetSchemas_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetSchemasReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetSchemas_args}) = __meta__GetSchemas_args



mutable struct GetSchemas_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetSchemas_result(; kwargs...)
    obj = new(__meta__GetSchemas_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetSchemas_result

const __meta__GetSchemas_result = meta(GetSchemas_result,
  Symbol[:success],
  Type[TGetSchemasResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetSchemas_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetSchemasResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetSchemas_result}) = __meta__GetSchemas_result


# types encapsulating arguments and return values of method GetTables

mutable struct GetTables_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTables_args(; kwargs...)
    obj = new(__meta__GetTables_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTables_args

const __meta__GetTables_args = meta(GetTables_args,
  Symbol[:req],
  Type[TGetTablesReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTables_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetTablesReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTables_args}) = __meta__GetTables_args



mutable struct GetTables_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTables_result(; kwargs...)
    obj = new(__meta__GetTables_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTables_result

const __meta__GetTables_result = meta(GetTables_result,
  Symbol[:success],
  Type[TGetTablesResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTables_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetTablesResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTables_result}) = __meta__GetTables_result


# types encapsulating arguments and return values of method GetTableTypes

mutable struct GetTableTypes_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTableTypes_args(; kwargs...)
    obj = new(__meta__GetTableTypes_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTableTypes_args

const __meta__GetTableTypes_args = meta(GetTableTypes_args,
  Symbol[:req],
  Type[TGetTableTypesReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTableTypes_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetTableTypesReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTableTypes_args}) = __meta__GetTableTypes_args



mutable struct GetTableTypes_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetTableTypes_result(; kwargs...)
    obj = new(__meta__GetTableTypes_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetTableTypes_result

const __meta__GetTableTypes_result = meta(GetTableTypes_result,
  Symbol[:success],
  Type[TGetTableTypesResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetTableTypes_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetTableTypesResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetTableTypes_result}) = __meta__GetTableTypes_result


# types encapsulating arguments and return values of method GetColumns

mutable struct GetColumns_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetColumns_args(; kwargs...)
    obj = new(__meta__GetColumns_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetColumns_args

const __meta__GetColumns_args = meta(GetColumns_args,
  Symbol[:req],
  Type[TGetColumnsReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetColumns_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetColumnsReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetColumns_args}) = __meta__GetColumns_args



mutable struct GetColumns_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetColumns_result(; kwargs...)
    obj = new(__meta__GetColumns_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetColumns_result

const __meta__GetColumns_result = meta(GetColumns_result,
  Symbol[:success],
  Type[TGetColumnsResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetColumns_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetColumnsResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetColumns_result}) = __meta__GetColumns_result


# types encapsulating arguments and return values of method GetFunctions

mutable struct GetFunctions_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetFunctions_args(; kwargs...)
    obj = new(__meta__GetFunctions_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetFunctions_args

const __meta__GetFunctions_args = meta(GetFunctions_args,
  Symbol[:req],
  Type[TGetFunctionsReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetFunctions_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetFunctionsReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetFunctions_args}) = __meta__GetFunctions_args



mutable struct GetFunctions_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetFunctions_result(; kwargs...)
    obj = new(__meta__GetFunctions_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetFunctions_result

const __meta__GetFunctions_result = meta(GetFunctions_result,
  Symbol[:success],
  Type[TGetFunctionsResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetFunctions_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetFunctionsResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetFunctions_result}) = __meta__GetFunctions_result


# types encapsulating arguments and return values of method GetPrimaryKeys

mutable struct GetPrimaryKeys_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetPrimaryKeys_args(; kwargs...)
    obj = new(__meta__GetPrimaryKeys_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetPrimaryKeys_args

const __meta__GetPrimaryKeys_args = meta(GetPrimaryKeys_args,
  Symbol[:req],
  Type[TGetPrimaryKeysReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetPrimaryKeys_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetPrimaryKeysReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetPrimaryKeys_args}) = __meta__GetPrimaryKeys_args



mutable struct GetPrimaryKeys_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetPrimaryKeys_result(; kwargs...)
    obj = new(__meta__GetPrimaryKeys_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetPrimaryKeys_result

const __meta__GetPrimaryKeys_result = meta(GetPrimaryKeys_result,
  Symbol[:success],
  Type[TGetPrimaryKeysResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetPrimaryKeys_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetPrimaryKeysResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetPrimaryKeys_result}) = __meta__GetPrimaryKeys_result


# types encapsulating arguments and return values of method GetCrossReference

mutable struct GetCrossReference_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetCrossReference_args(; kwargs...)
    obj = new(__meta__GetCrossReference_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetCrossReference_args

const __meta__GetCrossReference_args = meta(GetCrossReference_args,
  Symbol[:req],
  Type[TGetCrossReferenceReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetCrossReference_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetCrossReferenceReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetCrossReference_args}) = __meta__GetCrossReference_args



mutable struct GetCrossReference_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetCrossReference_result(; kwargs...)
    obj = new(__meta__GetCrossReference_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetCrossReference_result

const __meta__GetCrossReference_result = meta(GetCrossReference_result,
  Symbol[:success],
  Type[TGetCrossReferenceResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetCrossReference_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetCrossReferenceResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetCrossReference_result}) = __meta__GetCrossReference_result


# types encapsulating arguments and return values of method GetOperationStatus

mutable struct GetOperationStatus_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetOperationStatus_args(; kwargs...)
    obj = new(__meta__GetOperationStatus_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetOperationStatus_args

const __meta__GetOperationStatus_args = meta(GetOperationStatus_args,
  Symbol[:req],
  Type[TGetOperationStatusReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetOperationStatus_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetOperationStatusReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetOperationStatus_args}) = __meta__GetOperationStatus_args



mutable struct GetOperationStatus_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetOperationStatus_result(; kwargs...)
    obj = new(__meta__GetOperationStatus_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetOperationStatus_result

const __meta__GetOperationStatus_result = meta(GetOperationStatus_result,
  Symbol[:success],
  Type[TGetOperationStatusResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetOperationStatus_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetOperationStatusResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetOperationStatus_result}) = __meta__GetOperationStatus_result


# types encapsulating arguments and return values of method CancelOperation

mutable struct CancelOperation_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CancelOperation_args(; kwargs...)
    obj = new(__meta__CancelOperation_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CancelOperation_args

const __meta__CancelOperation_args = meta(CancelOperation_args,
  Symbol[:req],
  Type[TCancelOperationReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CancelOperation_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TCancelOperationReq
  else
    getfield(obj, name)
  end
end

meta(::Type{CancelOperation_args}) = __meta__CancelOperation_args



mutable struct CancelOperation_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CancelOperation_result(; kwargs...)
    obj = new(__meta__CancelOperation_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CancelOperation_result

const __meta__CancelOperation_result = meta(CancelOperation_result,
  Symbol[:success],
  Type[TCancelOperationResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CancelOperation_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TCancelOperationResp
  else
    getfield(obj, name)
  end
end

meta(::Type{CancelOperation_result}) = __meta__CancelOperation_result


# types encapsulating arguments and return values of method CloseOperation

mutable struct CloseOperation_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CloseOperation_args(; kwargs...)
    obj = new(__meta__CloseOperation_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CloseOperation_args

const __meta__CloseOperation_args = meta(CloseOperation_args,
  Symbol[:req],
  Type[TCloseOperationReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CloseOperation_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TCloseOperationReq
  else
    getfield(obj, name)
  end
end

meta(::Type{CloseOperation_args}) = __meta__CloseOperation_args



mutable struct CloseOperation_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CloseOperation_result(; kwargs...)
    obj = new(__meta__CloseOperation_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CloseOperation_result

const __meta__CloseOperation_result = meta(CloseOperation_result,
  Symbol[:success],
  Type[TCloseOperationResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CloseOperation_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TCloseOperationResp
  else
    getfield(obj, name)
  end
end

meta(::Type{CloseOperation_result}) = __meta__CloseOperation_result


# types encapsulating arguments and return values of method GetResultSetMetadata

mutable struct GetResultSetMetadata_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetResultSetMetadata_args(; kwargs...)
    obj = new(__meta__GetResultSetMetadata_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetResultSetMetadata_args

const __meta__GetResultSetMetadata_args = meta(GetResultSetMetadata_args,
  Symbol[:req],
  Type[TGetResultSetMetadataReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetResultSetMetadata_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetResultSetMetadataReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetResultSetMetadata_args}) = __meta__GetResultSetMetadata_args



mutable struct GetResultSetMetadata_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetResultSetMetadata_result(; kwargs...)
    obj = new(__meta__GetResultSetMetadata_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetResultSetMetadata_result

const __meta__GetResultSetMetadata_result = meta(GetResultSetMetadata_result,
  Symbol[:success],
  Type[TGetResultSetMetadataResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetResultSetMetadata_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetResultSetMetadataResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetResultSetMetadata_result}) = __meta__GetResultSetMetadata_result


# types encapsulating arguments and return values of method FetchResults

mutable struct FetchResults_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function FetchResults_args(; kwargs...)
    obj = new(__meta__FetchResults_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct FetchResults_args

const __meta__FetchResults_args = meta(FetchResults_args,
  Symbol[:req],
  Type[TFetchResultsReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::FetchResults_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TFetchResultsReq
  else
    getfield(obj, name)
  end
end

meta(::Type{FetchResults_args}) = __meta__FetchResults_args



mutable struct FetchResults_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function FetchResults_result(; kwargs...)
    obj = new(__meta__FetchResults_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct FetchResults_result

const __meta__FetchResults_result = meta(FetchResults_result,
  Symbol[:success],
  Type[TFetchResultsResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::FetchResults_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TFetchResultsResp
  else
    getfield(obj, name)
  end
end

meta(::Type{FetchResults_result}) = __meta__FetchResults_result


# types encapsulating arguments and return values of method GetDelegationToken

mutable struct GetDelegationToken_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetDelegationToken_args(; kwargs...)
    obj = new(__meta__GetDelegationToken_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetDelegationToken_args

const __meta__GetDelegationToken_args = meta(GetDelegationToken_args,
  Symbol[:req],
  Type[TGetDelegationTokenReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetDelegationToken_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetDelegationTokenReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetDelegationToken_args}) = __meta__GetDelegationToken_args



mutable struct GetDelegationToken_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetDelegationToken_result(; kwargs...)
    obj = new(__meta__GetDelegationToken_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetDelegationToken_result

const __meta__GetDelegationToken_result = meta(GetDelegationToken_result,
  Symbol[:success],
  Type[TGetDelegationTokenResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetDelegationToken_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetDelegationTokenResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetDelegationToken_result}) = __meta__GetDelegationToken_result


# types encapsulating arguments and return values of method CancelDelegationToken

mutable struct CancelDelegationToken_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CancelDelegationToken_args(; kwargs...)
    obj = new(__meta__CancelDelegationToken_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CancelDelegationToken_args

const __meta__CancelDelegationToken_args = meta(CancelDelegationToken_args,
  Symbol[:req],
  Type[TCancelDelegationTokenReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CancelDelegationToken_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TCancelDelegationTokenReq
  else
    getfield(obj, name)
  end
end

meta(::Type{CancelDelegationToken_args}) = __meta__CancelDelegationToken_args



mutable struct CancelDelegationToken_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function CancelDelegationToken_result(; kwargs...)
    obj = new(__meta__CancelDelegationToken_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct CancelDelegationToken_result

const __meta__CancelDelegationToken_result = meta(CancelDelegationToken_result,
  Symbol[:success],
  Type[TCancelDelegationTokenResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::CancelDelegationToken_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TCancelDelegationTokenResp
  else
    getfield(obj, name)
  end
end

meta(::Type{CancelDelegationToken_result}) = __meta__CancelDelegationToken_result


# types encapsulating arguments and return values of method RenewDelegationToken

mutable struct RenewDelegationToken_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function RenewDelegationToken_args(; kwargs...)
    obj = new(__meta__RenewDelegationToken_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct RenewDelegationToken_args

const __meta__RenewDelegationToken_args = meta(RenewDelegationToken_args,
  Symbol[:req],
  Type[TRenewDelegationTokenReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::RenewDelegationToken_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TRenewDelegationTokenReq
  else
    getfield(obj, name)
  end
end

meta(::Type{RenewDelegationToken_args}) = __meta__RenewDelegationToken_args



mutable struct RenewDelegationToken_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function RenewDelegationToken_result(; kwargs...)
    obj = new(__meta__RenewDelegationToken_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct RenewDelegationToken_result

const __meta__RenewDelegationToken_result = meta(RenewDelegationToken_result,
  Symbol[:success],
  Type[TRenewDelegationTokenResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::RenewDelegationToken_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TRenewDelegationTokenResp
  else
    getfield(obj, name)
  end
end

meta(::Type{RenewDelegationToken_result}) = __meta__RenewDelegationToken_result


# types encapsulating arguments and return values of method GetQueryId

mutable struct GetQueryId_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetQueryId_args(; kwargs...)
    obj = new(__meta__GetQueryId_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetQueryId_args

const __meta__GetQueryId_args = meta(GetQueryId_args,
  Symbol[:req],
  Type[TGetQueryIdReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetQueryId_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TGetQueryIdReq
  else
    getfield(obj, name)
  end
end

meta(::Type{GetQueryId_args}) = __meta__GetQueryId_args



mutable struct GetQueryId_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function GetQueryId_result(; kwargs...)
    obj = new(__meta__GetQueryId_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct GetQueryId_result

const __meta__GetQueryId_result = meta(GetQueryId_result,
  Symbol[:success],
  Type[TGetQueryIdResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::GetQueryId_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TGetQueryIdResp
  else
    getfield(obj, name)
  end
end

meta(::Type{GetQueryId_result}) = __meta__GetQueryId_result


# types encapsulating arguments and return values of method SetClientInfo

mutable struct SetClientInfo_args <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function SetClientInfo_args(; kwargs...)
    obj = new(__meta__SetClientInfo_args, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct SetClientInfo_args

const __meta__SetClientInfo_args = meta(SetClientInfo_args,
  Symbol[:req],
  Type[TSetClientInfoReq],
  Symbol[],
  Int[],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::SetClientInfo_args, name::Symbol)
  if name === :req
    return (obj.values[name])::TSetClientInfoReq
  else
    getfield(obj, name)
  end
end

meta(::Type{SetClientInfo_args}) = __meta__SetClientInfo_args



mutable struct SetClientInfo_result <: Thrift.TMsg
  meta::ThriftMeta
  values::Dict{Symbol,Any}
  
  function SetClientInfo_result(; kwargs...)
    obj = new(__meta__SetClientInfo_result, Dict{Symbol,Any}())
    values = obj.values
    symdict = obj.meta.symdict
    for nv in kwargs
      fldname, fldval = nv
      fldtype = symdict[fldname].jtype
      (fldname in keys(symdict)) || error(string(typeof(obj), " has no field with name ", fldname))
      values[fldname] = isa(fldval, fldtype) ? fldval : convert(fldtype, fldval)
    end
    Thrift.setdefaultproperties!(obj)
    obj
  end
end # mutable struct SetClientInfo_result

const __meta__SetClientInfo_result = meta(SetClientInfo_result,
  Symbol[:success],
  Type[TSetClientInfoResp],
  Symbol[],
  Int[0],
  Dict{Symbol,Any}()
)

function Base.getproperty(obj::SetClientInfo_result, name::Symbol)
  if name === :success
    return (obj.values[name])::TSetClientInfoResp
  else
    getfield(obj, name)
  end
end

meta(::Type{SetClientInfo_result}) = __meta__SetClientInfo_result




# Processor for TCLIService service (to be used in server implementation)
mutable struct TCLIServiceProcessor <: TProcessor
  tp::ThriftProcessor
  function TCLIServiceProcessor()
    p = new(ThriftProcessor())
    handle(p.tp, ThriftHandler("OpenSession", _OpenSession, OpenSession_args, OpenSession_result))
    handle(p.tp, ThriftHandler("CloseSession", _CloseSession, CloseSession_args, CloseSession_result))
    handle(p.tp, ThriftHandler("GetInfo", _GetInfo, GetInfo_args, GetInfo_result))
    handle(p.tp, ThriftHandler("ExecuteStatement", _ExecuteStatement, ExecuteStatement_args, ExecuteStatement_result))
    handle(p.tp, ThriftHandler("GetTypeInfo", _GetTypeInfo, GetTypeInfo_args, GetTypeInfo_result))
    handle(p.tp, ThriftHandler("GetCatalogs", _GetCatalogs, GetCatalogs_args, GetCatalogs_result))
    handle(p.tp, ThriftHandler("GetSchemas", _GetSchemas, GetSchemas_args, GetSchemas_result))
    handle(p.tp, ThriftHandler("GetTables", _GetTables, GetTables_args, GetTables_result))
    handle(p.tp, ThriftHandler("GetTableTypes", _GetTableTypes, GetTableTypes_args, GetTableTypes_result))
    handle(p.tp, ThriftHandler("GetColumns", _GetColumns, GetColumns_args, GetColumns_result))
    handle(p.tp, ThriftHandler("GetFunctions", _GetFunctions, GetFunctions_args, GetFunctions_result))
    handle(p.tp, ThriftHandler("GetPrimaryKeys", _GetPrimaryKeys, GetPrimaryKeys_args, GetPrimaryKeys_result))
    handle(p.tp, ThriftHandler("GetCrossReference", _GetCrossReference, GetCrossReference_args, GetCrossReference_result))
    handle(p.tp, ThriftHandler("GetOperationStatus", _GetOperationStatus, GetOperationStatus_args, GetOperationStatus_result))
    handle(p.tp, ThriftHandler("CancelOperation", _CancelOperation, CancelOperation_args, CancelOperation_result))
    handle(p.tp, ThriftHandler("CloseOperation", _CloseOperation, CloseOperation_args, CloseOperation_result))
    handle(p.tp, ThriftHandler("GetResultSetMetadata", _GetResultSetMetadata, GetResultSetMetadata_args, GetResultSetMetadata_result))
    handle(p.tp, ThriftHandler("FetchResults", _FetchResults, FetchResults_args, FetchResults_result))
    handle(p.tp, ThriftHandler("GetDelegationToken", _GetDelegationToken, GetDelegationToken_args, GetDelegationToken_result))
    handle(p.tp, ThriftHandler("CancelDelegationToken", _CancelDelegationToken, CancelDelegationToken_args, CancelDelegationToken_result))
    handle(p.tp, ThriftHandler("RenewDelegationToken", _RenewDelegationToken, RenewDelegationToken_args, RenewDelegationToken_result))
    handle(p.tp, ThriftHandler("GetQueryId", _GetQueryId, GetQueryId_args, GetQueryId_result))
    handle(p.tp, ThriftHandler("SetClientInfo", _SetClientInfo, SetClientInfo_args, SetClientInfo_result))
    p
  end
end # mutable struct TCLIServiceProcessor
_OpenSession(inp::OpenSession_args) = OpenSession_result(; success=OpenSession(inp.req))
_CloseSession(inp::CloseSession_args) = CloseSession_result(; success=CloseSession(inp.req))
_GetInfo(inp::GetInfo_args) = GetInfo_result(; success=GetInfo(inp.req))
_ExecuteStatement(inp::ExecuteStatement_args) = ExecuteStatement_result(; success=ExecuteStatement(inp.req))
_GetTypeInfo(inp::GetTypeInfo_args) = GetTypeInfo_result(; success=GetTypeInfo(inp.req))
_GetCatalogs(inp::GetCatalogs_args) = GetCatalogs_result(; success=GetCatalogs(inp.req))
_GetSchemas(inp::GetSchemas_args) = GetSchemas_result(; success=GetSchemas(inp.req))
_GetTables(inp::GetTables_args) = GetTables_result(; success=GetTables(inp.req))
_GetTableTypes(inp::GetTableTypes_args) = GetTableTypes_result(; success=GetTableTypes(inp.req))
_GetColumns(inp::GetColumns_args) = GetColumns_result(; success=GetColumns(inp.req))
_GetFunctions(inp::GetFunctions_args) = GetFunctions_result(; success=GetFunctions(inp.req))
_GetPrimaryKeys(inp::GetPrimaryKeys_args) = GetPrimaryKeys_result(; success=GetPrimaryKeys(inp.req))
_GetCrossReference(inp::GetCrossReference_args) = GetCrossReference_result(; success=GetCrossReference(inp.req))
_GetOperationStatus(inp::GetOperationStatus_args) = GetOperationStatus_result(; success=GetOperationStatus(inp.req))
_CancelOperation(inp::CancelOperation_args) = CancelOperation_result(; success=CancelOperation(inp.req))
_CloseOperation(inp::CloseOperation_args) = CloseOperation_result(; success=CloseOperation(inp.req))
_GetResultSetMetadata(inp::GetResultSetMetadata_args) = GetResultSetMetadata_result(; success=GetResultSetMetadata(inp.req))
_FetchResults(inp::FetchResults_args) = FetchResults_result(; success=FetchResults(inp.req))
_GetDelegationToken(inp::GetDelegationToken_args) = GetDelegationToken_result(; success=GetDelegationToken(inp.req))
_CancelDelegationToken(inp::CancelDelegationToken_args) = CancelDelegationToken_result(; success=CancelDelegationToken(inp.req))
_RenewDelegationToken(inp::RenewDelegationToken_args) = RenewDelegationToken_result(; success=RenewDelegationToken(inp.req))
_GetQueryId(inp::GetQueryId_args) = GetQueryId_result(; success=GetQueryId(inp.req))
_SetClientInfo(inp::SetClientInfo_args) = SetClientInfo_result(; success=SetClientInfo(inp.req))
process(p::TCLIServiceProcessor, inp::TProtocol, outp::TProtocol) = process(p.tp, inp, outp)
distribute(p::TCLIServiceProcessor) = distribute(p.tp)


# Server side methods to be defined by user:
# function OpenSession(req::TOpenSessionReq)
#     # returns TOpenSessionResp
# function CloseSession(req::TCloseSessionReq)
#     # returns TCloseSessionResp
# function GetInfo(req::TGetInfoReq)
#     # returns TGetInfoResp
# function ExecuteStatement(req::TExecuteStatementReq)
#     # returns TExecuteStatementResp
# function GetTypeInfo(req::TGetTypeInfoReq)
#     # returns TGetTypeInfoResp
# function GetCatalogs(req::TGetCatalogsReq)
#     # returns TGetCatalogsResp
# function GetSchemas(req::TGetSchemasReq)
#     # returns TGetSchemasResp
# function GetTables(req::TGetTablesReq)
#     # returns TGetTablesResp
# function GetTableTypes(req::TGetTableTypesReq)
#     # returns TGetTableTypesResp
# function GetColumns(req::TGetColumnsReq)
#     # returns TGetColumnsResp
# function GetFunctions(req::TGetFunctionsReq)
#     # returns TGetFunctionsResp
# function GetPrimaryKeys(req::TGetPrimaryKeysReq)
#     # returns TGetPrimaryKeysResp
# function GetCrossReference(req::TGetCrossReferenceReq)
#     # returns TGetCrossReferenceResp
# function GetOperationStatus(req::TGetOperationStatusReq)
#     # returns TGetOperationStatusResp
# function CancelOperation(req::TCancelOperationReq)
#     # returns TCancelOperationResp
# function CloseOperation(req::TCloseOperationReq)
#     # returns TCloseOperationResp
# function GetResultSetMetadata(req::TGetResultSetMetadataReq)
#     # returns TGetResultSetMetadataResp
# function FetchResults(req::TFetchResultsReq)
#     # returns TFetchResultsResp
# function GetDelegationToken(req::TGetDelegationTokenReq)
#     # returns TGetDelegationTokenResp
# function CancelDelegationToken(req::TCancelDelegationTokenReq)
#     # returns TCancelDelegationTokenResp
# function RenewDelegationToken(req::TRenewDelegationTokenReq)
#     # returns TRenewDelegationTokenResp
# function GetQueryId(req::TGetQueryIdReq)
#     # returns TGetQueryIdResp
# function SetClientInfo(req::TSetClientInfoReq)
#     # returns TSetClientInfoResp


# Client implementation for TCLIService service
mutable struct TCLIServiceClient <: TCLIServiceClientBase
  p::TProtocol
  seqid::Int32
  TCLIServiceClient(p::TProtocol) = new(p, 0)
end # mutable struct TCLIServiceClient

# Client callable method for OpenSession
function OpenSession(c::TCLIServiceClientBase, req::TOpenSessionReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "OpenSession", Thrift.MessageType.CALL, c.seqid)
  inp = OpenSession_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, OpenSession_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function OpenSession

# Client callable method for CloseSession
function CloseSession(c::TCLIServiceClientBase, req::TCloseSessionReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "CloseSession", Thrift.MessageType.CALL, c.seqid)
  inp = CloseSession_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, CloseSession_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function CloseSession

# Client callable method for GetInfo
function GetInfo(c::TCLIServiceClientBase, req::TGetInfoReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetInfo", Thrift.MessageType.CALL, c.seqid)
  inp = GetInfo_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetInfo_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetInfo

# Client callable method for ExecuteStatement
function ExecuteStatement(c::TCLIServiceClientBase, req::TExecuteStatementReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "ExecuteStatement", Thrift.MessageType.CALL, c.seqid)
  inp = ExecuteStatement_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, ExecuteStatement_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function ExecuteStatement

# Client callable method for GetTypeInfo
function GetTypeInfo(c::TCLIServiceClientBase, req::TGetTypeInfoReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetTypeInfo", Thrift.MessageType.CALL, c.seqid)
  inp = GetTypeInfo_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetTypeInfo_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetTypeInfo

# Client callable method for GetCatalogs
function GetCatalogs(c::TCLIServiceClientBase, req::TGetCatalogsReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetCatalogs", Thrift.MessageType.CALL, c.seqid)
  inp = GetCatalogs_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetCatalogs_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetCatalogs

# Client callable method for GetSchemas
function GetSchemas(c::TCLIServiceClientBase, req::TGetSchemasReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetSchemas", Thrift.MessageType.CALL, c.seqid)
  inp = GetSchemas_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetSchemas_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetSchemas

# Client callable method for GetTables
function GetTables(c::TCLIServiceClientBase, req::TGetTablesReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetTables", Thrift.MessageType.CALL, c.seqid)
  inp = GetTables_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetTables_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetTables

# Client callable method for GetTableTypes
function GetTableTypes(c::TCLIServiceClientBase, req::TGetTableTypesReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetTableTypes", Thrift.MessageType.CALL, c.seqid)
  inp = GetTableTypes_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetTableTypes_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetTableTypes

# Client callable method for GetColumns
function GetColumns(c::TCLIServiceClientBase, req::TGetColumnsReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetColumns", Thrift.MessageType.CALL, c.seqid)
  inp = GetColumns_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetColumns_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetColumns

# Client callable method for GetFunctions
function GetFunctions(c::TCLIServiceClientBase, req::TGetFunctionsReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetFunctions", Thrift.MessageType.CALL, c.seqid)
  inp = GetFunctions_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetFunctions_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetFunctions

# Client callable method for GetPrimaryKeys
function GetPrimaryKeys(c::TCLIServiceClientBase, req::TGetPrimaryKeysReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetPrimaryKeys", Thrift.MessageType.CALL, c.seqid)
  inp = GetPrimaryKeys_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetPrimaryKeys_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetPrimaryKeys

# Client callable method for GetCrossReference
function GetCrossReference(c::TCLIServiceClientBase, req::TGetCrossReferenceReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetCrossReference", Thrift.MessageType.CALL, c.seqid)
  inp = GetCrossReference_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetCrossReference_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetCrossReference

# Client callable method for GetOperationStatus
function GetOperationStatus(c::TCLIServiceClientBase, req::TGetOperationStatusReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetOperationStatus", Thrift.MessageType.CALL, c.seqid)
  inp = GetOperationStatus_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetOperationStatus_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetOperationStatus

# Client callable method for CancelOperation
function CancelOperation(c::TCLIServiceClientBase, req::TCancelOperationReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "CancelOperation", Thrift.MessageType.CALL, c.seqid)
  inp = CancelOperation_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, CancelOperation_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function CancelOperation

# Client callable method for CloseOperation
function CloseOperation(c::TCLIServiceClientBase, req::TCloseOperationReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "CloseOperation", Thrift.MessageType.CALL, c.seqid)
  inp = CloseOperation_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, CloseOperation_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function CloseOperation

# Client callable method for GetResultSetMetadata
function GetResultSetMetadata(c::TCLIServiceClientBase, req::TGetResultSetMetadataReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetResultSetMetadata", Thrift.MessageType.CALL, c.seqid)
  inp = GetResultSetMetadata_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetResultSetMetadata_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetResultSetMetadata

# Client callable method for FetchResults
function FetchResults(c::TCLIServiceClientBase, req::TFetchResultsReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "FetchResults", Thrift.MessageType.CALL, c.seqid)
  inp = FetchResults_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, FetchResults_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function FetchResults

# Client callable method for GetDelegationToken
function GetDelegationToken(c::TCLIServiceClientBase, req::TGetDelegationTokenReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetDelegationToken", Thrift.MessageType.CALL, c.seqid)
  inp = GetDelegationToken_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetDelegationToken_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetDelegationToken

# Client callable method for CancelDelegationToken
function CancelDelegationToken(c::TCLIServiceClientBase, req::TCancelDelegationTokenReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "CancelDelegationToken", Thrift.MessageType.CALL, c.seqid)
  inp = CancelDelegationToken_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, CancelDelegationToken_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function CancelDelegationToken

# Client callable method for RenewDelegationToken
function RenewDelegationToken(c::TCLIServiceClientBase, req::TRenewDelegationTokenReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "RenewDelegationToken", Thrift.MessageType.CALL, c.seqid)
  inp = RenewDelegationToken_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, RenewDelegationToken_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function RenewDelegationToken

# Client callable method for GetQueryId
function GetQueryId(c::TCLIServiceClientBase, req::TGetQueryIdReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "GetQueryId", Thrift.MessageType.CALL, c.seqid)
  inp = GetQueryId_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, GetQueryId_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function GetQueryId

# Client callable method for SetClientInfo
function SetClientInfo(c::TCLIServiceClientBase, req::TSetClientInfoReq)
  p = c.p
  c.seqid = (c.seqid < (2^31-1)) ? (c.seqid+1) : 0
  Thrift.writeMessageBegin(p, "SetClientInfo", Thrift.MessageType.CALL, c.seqid)
  inp = SetClientInfo_args()
  inp.req = req
  Thrift.write(p, inp)
  Thrift.writeMessageEnd(p)
  Thrift.flush(p.t)
  
  (fname, mtype, rseqid) = Thrift.readMessageBegin(p)
  (mtype == Thrift.MessageType.EXCEPTION) && throw(Thrift.read(p, Thrift.TApplicationException()))
  outp = Thrift.read(p, SetClientInfo_result())
  Thrift.readMessageEnd(p)
  (rseqid != c.seqid) && throw(Thrift.TApplicationException(; typ=ApplicationExceptionType.BAD_SEQUENCE_ID, message="response sequence id $rseqid did not match request ($(c.seqid))"))
  hasproperty(outp, :success) && (return outp.success)
  throw(Thrift.TApplicationException(; typ=Thrift.ApplicationExceptionType.MISSING_RESULT, message="retrieve failed: unknown result"))
end # function SetClientInfo

